#usda 1.0
(
    customLayerData = {
        dictionary cameraSettings = {
            dictionary Front = {
                double3 position = (5, 0, 0)
                double radius = 5
            }
            dictionary Perspective = {
                double3 position = (2.0881175973840937, -1.1243412889930062, 0.8758621826629149)
                double3 target = (-0.8898607167546211, -0.032383770740412654, 0.6034999830722094)
            }
            dictionary Right = {
                double3 position = (0, -5, 0)
                double radius = 5
            }
            dictionary Top = {
                double3 position = (0, 0, 5)
                double radius = 5
            }
            string boundCamera = "/OmniverseKit_Persp"
        }
        dictionary omni_layer = {
            string authoring_layer = "./franks_world.usda"
            dictionary locked = {
                bool "./props/looks.usd" = 1
                bool "./props/model.usd" = 1
                bool "./props/physics.usd" = 1
                bool "./props/scale.usd" = 1
                bool "./props/sensor.usd" = 1
            }
        }
        dictionary physicsSettings = {
            int "/persistent/simulation/minFrameRate" = 60
        }
        dictionary renderSettings = {
            float3 "rtx:debugView:pixelDebug:textColor" = (0, 1e18, 0)
            float3 "rtx:fog:fogColor" = (0.75, 0.75, 0.75)
            float3 "rtx:index:backgroundColor" = (0, 0, 0)
            float3 "rtx:index:regionOfInterestMax" = (0, 0, 0)
            float3 "rtx:index:regionOfInterestMin" = (0, 0, 0)
            float3 "rtx:post:backgroundZeroAlpha:backgroundDefaultColor" = (0, 0, 0)
            float3 "rtx:post:colorcorr:contrast" = (1, 1, 1)
            float3 "rtx:post:colorcorr:gain" = (1, 1, 1)
            float3 "rtx:post:colorcorr:gamma" = (1, 1, 1)
            float3 "rtx:post:colorcorr:offset" = (0, 0, 0)
            float3 "rtx:post:colorcorr:saturation" = (1, 1, 1)
            float3 "rtx:post:colorgrad:blackpoint" = (0, 0, 0)
            float3 "rtx:post:colorgrad:contrast" = (1, 1, 1)
            float3 "rtx:post:colorgrad:gain" = (1, 1, 1)
            float3 "rtx:post:colorgrad:gamma" = (1, 1, 1)
            float3 "rtx:post:colorgrad:lift" = (0, 0, 0)
            float3 "rtx:post:colorgrad:multiply" = (1, 1, 1)
            float3 "rtx:post:colorgrad:offset" = (0, 0, 0)
            float3 "rtx:post:colorgrad:whitepoint" = (1, 1, 1)
            float3 "rtx:post:lensDistortion:lensFocalLengthArray" = (10, 30, 50)
            float3 "rtx:post:lensFlares:anisoFlareFalloffX" = (450, 475, 500)
            float3 "rtx:post:lensFlares:anisoFlareFalloffY" = (10, 10, 10)
            float3 "rtx:post:lensFlares:cutoffPoint" = (2, 2, 2)
            float3 "rtx:post:lensFlares:haloFlareFalloff" = (10, 10, 10)
            float3 "rtx:post:lensFlares:haloFlareRadius" = (75, 75, 75)
            float3 "rtx:post:lensFlares:isotropicFlareFalloff" = (50, 50, 50)
            float3 "rtx:post:tonemap:whitepoint" = (1, 1, 1)
            float3 "rtx:raytracing:indexdirect:svoBrickSize" = (32, 32, 32)
            float3 "rtx:raytracing:inscattering:singleScatteringAlbedo" = (0.9, 0.9, 0.9)
            float3 "rtx:raytracing:inscattering:transmittanceColor" = (0.5, 0.5, 0.5)
            float3 "rtx:sceneDb:ambientLightColor" = (0.1, 0.1, 0.1)
        }
    }
    defaultPrim = "World"
    endTimeCode = 1000000
    metersPerUnit = 1
    startTimeCode = 0
    subLayers = [
        @./props/sensor.usd@,
        @./props/physics.usd@,
        @./props/looks.usd@,
        @./props/scale.usd@,
        @./props/model.usd@
    ]
    timeCodesPerSecond = 60
    upAxis = "Z"
)

def Xform "World"
{
    custom string cmd_path = ""

    def Xform "GroundPlane"
    {
        quatf xformOp:orient = (1, 0, 0, 0)
        float3 xformOp:scale = (1, 1, 1)
        double3 xformOp:translate = (0, 0, 0)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

        def Mesh "CollisionMesh"
        {
            uniform bool doubleSided = 0
            int[] faceVertexCounts = [4]
            int[] faceVertexIndices = [0, 1, 2, 3]
            normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1)]
            point3f[] points = [(-25, -25, 0), (25, -25, 0), (25, 25, 0), (-25, 25, 0)]
            color3f[] primvars:displayColor = [(0.5, 0.5, 0.5)]
            bool primvars:isMatteObject = 1
            texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1)] (
                interpolation = "varying"
            )
        }

        def Plane "CollisionPlane" (
            prepend apiSchemas = ["PhysicsCollisionAPI"]
        )
        {
            uniform token axis = "Z"
            bool primvars:isMatteObject = 1
            uniform token purpose = "guide"
        }
    }

    over "base_link"
    {
        quatd xformOp:orient = (0.27059805393218994, 0.27059805393218994, 0.6532815098762512, 0.6532815098762512)
        float3 xformOp:scale = (0.01, 0.01, 0.01)
        double3 xformOp:translate = (1, 1, 0.5)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

        over "base_link_grp"
        {
        }

        over "z_link"
        {
        }

        over "y_link"
        {
            over "Camera"
            {
                custom token cameraProjectionType (
                    allowedTokens = ["pinhole", "fisheyeOrthographic", "fisheyeEquidistant", "fisheyeEquisolid", "fisheyePolynomial", "fisheyeSpherical", "fisheyeKannalaBrandtK3", "fisheyeRadTanThinPrism", "omniDirectionalStereo"]
                )
                float focalLength = 30
                custom float fthetaCx
                custom float fthetaCy
                custom float fthetaHeight
                custom float fthetaMaxFov
                custom float fthetaPolyA
                custom float fthetaPolyB
                custom float fthetaPolyC
                custom float fthetaPolyD
                custom float fthetaPolyE
                custom float fthetaWidth
                quatd xformOp:orient = (1, 0, 0, 0)
                double3 xformOp:translate = (-0.0000010778094292618334, 0, -4.5)
                uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]
            }
        }
    }

    over "nova_carter"
    {
        quatd xformOp:orient = (0.7071067811865476, 0, 0, 0.7071067811865475)
        double3 xformOp:scale = (2, 2, 2)
        double3 xformOp:translate = (-9.5, -0.25, 0)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

        over "chassis_link"
        {
        }

        over "caster_frame_base"
        {
        }

        over "caster_swivel_left"
        {
        }

        over "caster_wheel_left"
        {
        }

        over "caster_swivel_right"
        {
        }

        over "caster_wheel_right"
        {
        }

        over "wheel_left"
        {
        }

        over "wheel_right"
        {
        }

        over "dummy_link"
        {
        }

        over "dummy_link_2"
        {
        }
    }

    def Mesh "Target" (
        prepend apiSchemas = ["SemanticsAPI:Semantics_1Vc4"]
    )
    {
        float3[] extent = [(-0.5, -0.5, -0.5), (0.5, 0.5, 0.5)]
        int[] faceVertexCounts = [4, 4, 4, 4, 4, 4]
        int[] faceVertexIndices = [0, 1, 3, 2, 4, 6, 7, 5, 6, 2, 3, 7, 4, 5, 1, 0, 4, 0, 2, 6, 5, 7, 3, 1]
        normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0)] (
            interpolation = "faceVarying"
        )
        point3f[] points = [(-0.5, -0.5, 0.5), (0.5, -0.5, 0.5), (-0.5, 0.5, 0.5), (0.5, 0.5, 0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, -0.5), (-0.5, 0.5, -0.5), (0.5, 0.5, -0.5)]
        texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0), (0, 1), (0, 0), (1, 0), (1, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0)] (
            interpolation = "faceVarying"
        )
        string semantic:Semantics_1Vc4:params:semanticData = "object"
        string semantic:Semantics_1Vc4:params:semanticType = "class"
        uniform token subdivisionScheme = "none"
        quatd xformOp:orient = (1, 0, 0, 0)
        double3 xformOp:scale = (0.05, 0.05, 0.05)
        double3 xformOp:translate = (0.4, 0, 0.025)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]
    }

    def Xform "Franka" (
        prepend references = @omniverse://localhost/NVIDIA/Assets/Isaac/4.0/Isaac/Robots/Franka/franka.usd@
    )
    {
        quatd xformOp:orient = (1, 0, 0, 0)
        double3 xformOp:translate = (0, 0, 0)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

        over "panda_rightfinger" (
            prepend apiSchemas = ["PhysxRigidBodyAPI"]
        )
        {
            float physxRigidBody:sleepThreshold = 0
        }
    }

    def RectLight "RectLight" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        float3[] extent = [(-50, -50, -0), (50, 50, 0)]
        float inputs:exposure = 0
        float inputs:height = 100
        float inputs:intensity = 8000
        bool inputs:normalize = 1
        float inputs:shaping:cone:angle = 180
        float inputs:shaping:cone:softness
        float inputs:shaping:focus
        color3f inputs:shaping:focusTint
        asset inputs:shaping:ies:file
        float inputs:width = 100
        bool visibleInPrimaryRay = 0
        quatd xformOp:orient = (0.7071067811865476, 0, 0, 0.7071067811865475)
        double3 xformOp:scale = (0.0007000000000030127, 0.0007000000000030127, 0.0007000000000030127)
        double3 xformOp:translate = (0.9131000543134977, -9.084533137818426e-15, 1.553758659902226)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]
    }
}

def Xform "Environment"
{
    quatd xformOp:orient = (1, 0, 0, 0)
    double3 xformOp:scale = (1, 1, 1)
    double3 xformOp:translate = (0, 0, 0)
    uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]

    def DomeLight "sky" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        float inputs:exposure = -1
        float inputs:intensity = 1000
        float inputs:shaping:cone:angle = 180
        float inputs:shaping:cone:softness
        float inputs:shaping:focus
        color3f inputs:shaping:focusTint
        asset inputs:shaping:ies:file
        float inputs:specular = 1
        asset inputs:texture:file = @https://omniverse-content-production.s3.us-west-2.amazonaws.com/Environments/2023_1/DomeLights/Indoor/ZetoCGcom_ExhibitionHall_Interior1.hdr@
        token inputs:texture:format = "latlong"
        token visibility = "inherited"
        bool visibleInPrimaryRay = 1
        quatd xformOp:orient = (1, 0, 0, 0)
        double3 xformOp:scale = (1, 1, 1)
        double3 xformOp:translate = (0, 0, 0)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient", "xformOp:scale"]
    }
}

def PhysicsScene "physicsScene" (
    prepend apiSchemas = ["PhysxSceneAPI"]
)
{
    vector3f physics:gravityDirection = (0, 0, -1)
    float physics:gravityMagnitude = 9.81
    uniform token physxScene:broadphaseType = "MBP"
    bool physxScene:enableCCD = 1
    bool physxScene:enableGPUDynamics = 0
    bool physxScene:enableStabilization = 1
    uniform token physxScene:solverType = "TGS"
    uint physxScene:timeStepsPerSecond = 60
}

